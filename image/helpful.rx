( adds an optional help system to the image. used by 'make helpful' at top level )
needs help'

:  :d  ( a$- ) keepString swap d->doc ! ;
d' :d "( a$- ) Like ^help'doc, but uses an arbitrary dictionary entry, instead of last" :d

( all docstrings were taken from ../doc/core_functions.rst )
( note: i tried to leave the markup intact, in hopes that we could generate that file from this -mjw )
d' 1+           "( n-n ) Increment TOS by 1 " :d
d' 1-           "( n-n ) Decrement TOS by 1 " :d
d' swap         "( xy-yx ) Exchange positions of TOS and NOS" :d
d' drop         "( n- ) Drop TOS from the stack" :d
d' and          "( xy-n ) Bitwise AND" :d
d' or           "( xy-n ) Bitwise OR" :d
d' xor          "( xy-n ) Bitwise XOR" :d
d' @            "( a-n ) Fetch a value from a memory location" :d
d' !            "( na- ) Store a value to a memory location" :d
d' +            "( xy-n ) Add two values (x+y)" :d
d' -            "( xy-n ) Subtract two values (x-y)" :d
d' *            "( xy-n ) Multiply two values (x*y)" :d
d' /mod         "( xy-rq ) Divide and Remainder. This performs symmetric division" :d
d' <<           "( xy-n ) Shift bits left (x<<y)" :d
d' >>           "( xy-n ) Shift bits right (x>>y)" :d
d' tib          "(  -a ) Returns address of text input buffer" :d
d' dup          "( n-nn ) Duplicate TOS" :d
d' in           "( p-n ) Read a value from an I/O port" :d
d' out          "( np- ) Write a value to an I/O port" :d
d' accept       "( c- ) Read a string, ending with the specified character. The string is returned in **tib**" :d
d' here         "( -a ) Next free address in **heap**" :d
d' ,            "( n- ) Place TOS **here** and increment **heap** by 1 " :d
d' create       "( ``- ) Parse for a name and call **header**" :d
d' :            "( ``- ) Calls **create**, changes class to **.word**, and turns **compiler** on." :d
d' header       "( $- ) Given a name, create a new header with a class of **.data**" :d
d' cr           "( - ) Display a newline character" :d
d' putc         "( c- ) Display a character" :d
d' remapKeys    "( c-c ) Remap one ASCII value to another" :d
d' <puts>       "( $- ) Helper; default way to display strings" :d
d' over         "( xy-xyx ) Place a copy of NOS over TOS" :d
d' ]]           "( - ) Turn compiler on" :d
d' not          "( x-y ) Same as -1 xor; invert TOS and subtract 1." :d
d' on           "( a- ) Set a variable to -1 (true)" :d
d' off          "( a- ) Set a variable to  0 (false)" :d
d' /            "( xy-q ) Divide two numbers (x/y)" :d
d' mod          "( xy-r ) Modulus of two numbers (x%y)" :d
d' negate       "( x-y ) Invert sign of TOS" :d
d' do           "( a- ) Call a function by address" :d
d' numbers      "(  -a ) Function returning address of string containing all valid numeric characters" :d
d' wait         "( - ) Wait for an I/O event" :d
d' '            "( ``-a ) Interpret time: return the address ('xt') of a name" :d
d' @+           "( a-ac ) Fetch a value from an address, return the next address and the value" :d
d' !+           "( ca-a ) Store a value to an address, return next      address" :d
d' keepString   "( a-a ) Move the string to a permanent location" :d
d' getLength    "( a-n ) Return the length of a string" :d
d' withLength   "( a-an ) Same as **dup getLength**" :d
d' withClass    "( ac- ) Execute a function via the specified class handler" :d
d' .word        "( a- ) Class for normal functions" :d
d' .macro       "( a- ) Class for immediate functions" :d
d' .data        "( a- ) Class for data (variables, literals, etc) " :d


d' d->class     "( a-a ) Given a dictionary header, return the address of the class handler. Use **@** to get the actual pointer." :d
d' d->xt        "( a-a ) Given a dictionary header, return the address of the function start (*xt*). Use **@** to get the actual pointer." :d
d' d->doc       "( a-a ) Given a dictionary header, return the address of a documentation string. Use **@** to get the actual pointer." :d
d' d->name      "( a-a ) Given a dictionary header, return the address of the name. This is the actual start of the  name." :d
d' boot         "( - ) Called when the image first loads; use for custom startup routines" :d
d' toNumber     "( $-n ) Convert a string to a number" :d
d' isNumber?    "( $-f ) See if a string is a valid number in the current **base**" :d
d' ok           "( - ) Displays the ``ok`` prompt" :d
d' listen       "( - ) Top level interpreter. Reads and process input." :d
d' getc         "( -c ) Read a keypress and return the ASCII value on the stack" :d
d' find         "( $-af ) Search for a name in the dictionary. Returns  a dictionary header and a flag" :d
d' notFound     "( - ) Called when a name is not found. Calls **<notFound>** and displays an error message  if necessary" :d
d' <notFound>   "( -f ) Called by **notFound**; hook for custom error handling. Used by the prefix system. Returns  a flag of 0 if the error is cleared, or -1 if not " :d
d' puts         "( $- ) Display a string" :d
d' compare      "( $$-f ) Compare two strings for equality" :d
d' redraw       "( -) Update the display. Can be disabled temporarily by **update**" :d
d' if           "( fqq- ) Execute first quote if flag is true, second  if false" :d
d' ifTrue       "( fq- ) Execute quote if flag is true" :d
d' ifFalse      "( fq- ) Execute quote if flag is false" :d
d' dip          "( nq-n ) Call a quote while temporarily hiding the top item on the stack" :d
d' sip          "( nq-n ) Call a quote with an item on the stack, restoring that item after the quote returns" :d
d' =            "( xy-f ) Compare two values for equality. Use **==** instead," :d
d' <>           "( xy-f ) Compare two values for inequality. Use **!=** instead." :d
d' <            "( xy-f ) Compare two values for less than" :d
d' >            "( xy-f ) Compare two values for greater than" :d
d' <=           "( xy-f ) Compare for less than or equal to" :d
d' >=           "( xy-f ) Compare for greater than or equal to" :d
d' ==           "( xy-f ) Compare two values for equality" :d
d' !=           "( xy-f ) Compare two values for inequality" :d
d' ;            "( - ) Compile an exit into a function and stop the compiler" :d
d' ;;           "( - ) Compile an exit into a function, but do not stop compilation" :d
d' repeat       "( - ) Start an unconditional loop" :d
d' again        "( - ) Jump to the code following the most recent **repeat**" :d
d' 0;           "( n-n ) If TOS is not zero, do nothing. If TOS is zero, drop TOS and exit the function" :d
d' push         "( n- ) Push a value to the address stack" :d
d' pop          "( -n ) Pop a value off the address stack" :d
d' (            "( ``- ) Parse for ) and ignore everything it reads" :d
d' [            "( - ) Start a quote (code block)" :d
d' ]            "( -a ) End a quote (code block)" :d
d' [[           "( - ) Turn compiler off" :d
d' last         "( -a ) Variable; pointer to most recent dictionary  header" :d
d' compiler     "( -a ) Variable; holds compiler state" :d
d' fb           "( -a ) Variable; Is canvas present?" :d
d' fw           "( -a ) Variable; Framebuffer width" :d
d' fh           "( -a ) Variable; Framebuffer height" :d
d' memory       "( -a ) Variable; Holds amount of memory provided by the VM" :d
d' cw           "( -a ) Variable; Console width" :d
d' ch           "( -a ) Variable; Console height" :d
d' heap         "( -a ) Variable; Pointer to current free location in heap" :d
d' which        "( -a ) Variable; Holds pointer to most recently looked up header" :d
d' remapping    "( -a ) Variable; indicates whether CR, LF, and TAB should be treated as whitespace" :d
d' eatLeading?  "( -a ) Variable; indicates whether **accept** should ignore leading delimiters" :d
d' base         "( -a ) Variable; holds current base for numeric conversion and display" :d
d' update       "( -a ) Variable; flag indicating whether or not **redraw** should update the display" :d
d' version      "( -$ ) String holding version information" :d
d' build        "( -$ ) String holding a build identifier" :d
d' tabAsWhitespace "( -a ) Variable; treat tab as whitespace?" :d
d' ?dup         "( -n ) Duplicate TOS if non-zero. If zero, leave" :d
d' nip          "( xy-y ) Drop the NOS from the stack" :d
d' rot          "( xyz-yzx ) Rotate the top three values on the stack" :d
d' tuck         "( xy-yxy ) Put a copy of TOS under NOS" :d
d' +!           "( na- ) Add value to value at address" :d
d' -!           "( na- ) Subtract value from value at address" :d
d' ++           "( a- ) Increment variable by 1" :d
d' --           "( a- ) Decrement variable by 1" :d
d' HEADERS      "( -n ) Returns number of private headers permitted" :d
d' {{           "( - ) Start a namespace (private portion)" :d
d' ---reveal--- "( - ) Switch to public portion of a namespace" :d
d' }}           "( - ) Close a namespace, sealing off private symbols" :d
d' :devector    "( a- ) Restore a function to its original state" :d
d' :is          "( aa- ) Alter a function to point to a new function" :d
d' devector     "( ``- ) Same as **:devector**, but parses for name of function" :d  )
d' is           "( a``- ) Same as **:is**, but parses for name of function" :d )
d' default:     "( ``- ) Compile call to default definition of a function, ignoring any revectoring" :d
d' d'           "( ``-a ) Parse for a name and return the dictionary header corresponding to it" :d
d' xt->d        "( a-d ) Given an address, return the corresponding dictionary header or 0 if not found" :d
d' :hide        "( a- ) Remove a name from a dictionary. Specify the address of a function. Used by **hide**" :d
d' hide         "( ``- ) Remove a name from the dictionary" :d
d' reclass      "( a- ) Change class of most recent function to specified class" :d
d' reclass:     "( a``- ) Same as **reclass**, but parse for function to change class of" :d
d' __&          "( a-a ) Prefix; returns address of a variable or function" :d
d' __@          "( a-n ) Prefix; execute function or data element and fetch from addres returned" :d
d' __!          "( na- ) Prefix; execute function or data element and store value to address returned" :d
d' __+          "( na- ) Prefix; execute function or data element and add value to value at address returned" :d
d' __-          "( na- ) Prefix; execute function or data element and subtract value from value at address returned" :d
d' __2          "( a- ) Prefix; execute function twice" :d
d' .primitive   "( a- ) Class for functions corresponding to VM opcodes; used for simple optimizations" :d
d' .compiler    "( a- ) Class for functions that can only be used inside a definition" :d
d' immediate    "( - ) Set the most recent function to **.macro** class" :d
d' compile-only "( ``- ) Set the most recent function to **.compiler** class" :d
d' `            "( ``- ) Either execute a function, or compile the xt  and a call to the corresponding class         handler. This will also work with numbers" :d
d' jump:        "( ``- ) Compile a jump to another function" :d
d' []           "( - ) Empty quote" :d
d' while        "( q- ) Execute quote until quote returns a flag of" :d
d' until        "( q- ) Execute quote until quote returns a flag of -1" :d
d' curry        "( nq-q ) 5 [ . ]   =  [ 5 [ . ] do ]" :d
d' take         "( qq-q ) 5 [ . ]   =  [ [ . ] do 5 ]" :d
d' bi           "(  xqq- ) Apply each quote to a copy of x" :d
d' bi*          "( xyqq- ) Apply q1 to x and q2 to y" :d
d' bi@          "(  xyq- ) Apply q to x and y" :d
d' tri          "( xqqq- ) Apply each quote to a copy of x" :d
d' tri*         "( xyzqqq- ) Apply q1 to x, q2 to y, and q3 to z" :d
d' tri@         "( xyzq- ) Apply q to x, y, and z" :d
d' cons         "( ab-q ) Create a quote returning two data elements" :d
d' preserve     "( aq- ) Given a variable (a) and a quote (q), preserve the contents of (a) while executing  the quote, and restore the original contents  of (a) after execution completes. (a) is removed from the stack before (q) is executed." :d
d' when         "( nqq-n ) Execute q1, with a copy of n on the stack.\n\nIf q1 returns a true flag, run q2 and exit the caller.\n\nIf not, discard q2 and return to the  caller.\n\nq2 is permitted to discard n, which will alter the stack effect." :d
d' whend        "( nqq-? ) Execute q1, with a copy of n on the stack.\n\nIf q1 returns a true flag, drop n, run q2 and exit the caller.\n\nIf not, discard q2 and return to the caller. " :d
d' times        "( nq- ) Run quote (n) times" :d
d' iterd        "( nq- ) Run quote (n) times and push counter to stack each time. Counts down." :d
d' iter         "( nq- ) Run quote (n) times and push counter to stack each time. Counts up." :d
d' <each@>      "( ...t- ) Hook into **each@** for adding additional types" :d

( TODO each@ )

d' copy         "( aan- ) Copy n values from source (a1) to dest (a2)" :d
d' fill         "( ann- ) Fill (n2) memory locations starting at (a) with value (n1)" :d
d' ahead        "( -a ) Used in conditionals; compiles a branch to be patched in later" :d
d' if;          "( f- ) Exit function if TOS is a non-zero flag" :d
d' within       "( xlu-f ) Is (x) within lower (l) and upper (u) bounds?" :d
d' variable:    "( n``- ) Create a new variable with an initial value " :d
d' variable     "( ``- ) Create a new variable with an initial value of 0" :d
d' constant     "( n``- ) Create a numeric constant" :d
d' string:      "( $``- ) Create a string constant" :d
d' allot        "( n- ) Allocate space in the heap" :d
d' elements     "( n``- ) Create a series of variables" :d
d' decimal      "( - ) Switch **base** to 10" :d
d' hex          "( - ) Switch **base** to 16" :d
d' octal        "( - ) Switch **base** to  8" :d
d' binary       "( - ) Switch **base** to  2" :d
d' toString     "( n-$ ) Convert a number into a string" :d
d' clear        "( - ) Clear the display" :d
d' space        "( - ) Display a space character (ASCII 32)" :d
d' putn         "( n- ) Display a number" :d
d' .parse       "( a- ) Class for parsing prefixes" :d
d' parsing      "( - ) Set most recent function to **.parse** class" :d
d' __$          "( $-n ) Prefix; treat number as hexadecimal (base" :d
d' __#          "( $-n ) Prefix; treat number as decimal (base 10)" :d
d' __%          "( $-n ) Prefix; treat number as binary (base 2)" :d
d' __'          "( $-n ) Return character following '" :d
d' dicts        "( -a ) Array; used by chained vocabularies and search order code" :d
d' %%           "( - ) Close a vocabulary. Use with caution" :d
d' <%>          "( a- ) Open a vocabulary. Use with caution" :d
d' .chain       "( a- ) Class for vocabularies" :d
d' chain:       "( ``- ) Create a new vocabulary" :d
d' ;chain       "( - ) End a vocabulary" :d
d' :with        "( a- ) Add a vocabulary to the search order (by pointer)" :d
d' with         "( ``- ) Add a vocabulary to the search order (parses for name)" :d
d' without      "( - ) Remove a vocabulary from the search order " :d
d' global       "( - ) Remove all vocabularies from the search order, leaving just the global dictionary " :d
d' findInChain  "( $a-df ) Open a chain (using **:with**) and search for a name. Closes the chain when done." :d
d' with|        "( ``- ) Open a series of vocabularies, ending when ``"``  is encountered" :d
d' rename:      "( a``- ) Rename a function" :d
d' STRING-LENGTH "( -n ) Return the max length for a string" :d
d' STRING-BUFFERS "( -n ) Return number of temporary string buffers" :d
d' tempString   "( a-a ) Move a string to a temporary buffer" :d
d' __"          "( ``-$ ) Prefix; parse and return a string" :d
d' "            "( ``-$ ) Parse and return a string" :d
d' formatted    "( -a ) Variable; toggles whether **puts** uses escape sequences or not" :d
d' depth        "( -n ) Return number of items on stack" :d
d' reset        "( ...- ) Remove all items from stack" :d
d' .s           "( - ) Display all items on stack" :d
d' words        "( - ) List all names in dictionary" :d
d' save         "( - ) Save the image" :d
d' bye          "( - ) Exit Retro" :d
d' getToken     "( ``-$ ) Read a string, stopping at first whitespace" :d
d' getNumber    "( ``-n ) Read a number from the input stream" :d
d' :include     "( $- ) Include a file" :d
d' include      "( ``- ) Same as **:include**, but parse for file name" :d
d' time         "( -n ) Return the current unix time" :d
d' delay        "( n- ) Delay for (approximately) n seconds" :d
d' getEnv       "( a$- ) Get a copy of environment variable $ in buffer" :d
d' later        "( - ) Defer execution of caller until a later time" :d
d' yield        "( - ) Return from a function, with execution resuming from point after **yield** when the  function is next called" :d
d' __^          "( ``- ) Allow direct access to functions in a chain" :d
d' :needs       "( $- ) Load a vocabulary from the library if not already loaded" :d
d' needs        "( ``- ) Load a vocabulary from the *library* if it is not already loaded (parsing)" :d
d' doc{         "( ``- ) Parse tokens up to *}doc* and ignore.\n\nThis is intended as a means of embedding docs into libraries." :d
d' variables|   "( ``- ) Create a series of variables" :d

( buffer' )
with buffer'
d' start "( -a ) Get starting address of buffer" :d
d' end   "( -a ) Address at end of buffer" :d
d' add   "( c- ) Add value to end of buffer" :d
d' get   "( -c ) Read and remove value from buffer" :d
d' empty "( - ) Remove everything from the buffer" :d
d' size  "( -n ) Number of values in buffer" :d
d' set   "( a- ) Set buffer to memory address and empty it" :d
without

( strings' )
with strings'
d' search     "( $$-f ) Search for a string (2) within a string (1); return string starting with substring" :d
d' findChar   "( $c-a ) Search for a character within a string; return string starting at the character" :d
d' chop       "( $-$ ) Return a new string, with the last byte removed" :d
d' getSubset  "( $nn-$ ) Return a subset of ($) starting at (n1) with length of (n2)" :d
d' trimLeft   "( $-$ ) Trim whitespace from left side of string" :d
d' trimRight  "( $-$ ) Trim whitespace from right side of string" :d
d' append     "( $$-$ ) Append second string to first" :d
d' appendChar "( $c-$ ) Append character to a string" :d
d' prepend    "( $$-$ ) Append first string to second" :d
d' toLower    "( $-$ ) Convert a string to all lower case" :d
d' toUpper    "( $-$ ) Convert a string to all upper case" :d
d' reverse    "( $-$ ) Reverse the characters in a string; returns a new string" :d
d' split      "( $n-$$ ) Split a string into two parts" :d
d' splitAtChar  "( $c-$$ ) Search for a character and return two strings (up to and including (c), and after ($2))" :d
d' splitAtChar: "( $``-$$ ) Parse for a character and call **splitAtChar**" :d
without

( types' )
with types'
d' ARRAY "( -n ) Type constant for arrays" :d
d' BUFFER  "( -n ) Type constant for buffers" :d
d' STRING  "( -n ) Type constant for strings" :d
d' LIST "( -n ) Type constant for linked lists" :d
without

( internals' )
with internals'
d' string       "( - ) Helper function for strings" :d
d' quote        "( -a ) Helper function for quotations" :d
without


( Footnotes )

( .. [1] This corresponds to an Ngaro instruction. ) 

( NOTE : I removed the one above because we can just have doc show the class )
( TODO : see what we can do about the rest of these )

( .. [2] Shifting by a negative amount is undefined behavior. Don't do it. )
( .. [3] **puts** supports escape sequences which alter the stack usage. )

( " Sequence " Stack " Used For                   " )
( " %s    " $- " Display a string           " )
( " %d    " n- " Display a number [decimal] " )
( " %x    " n- " Display a number [hexadecimal]" )
( " %o    " n- " Display a number [octal] " )
( " %c    " c- " Display a character        " )
( " \\n   " - " Newline                    " )
( " \\'   " - " Display a double quote " " )
( " \\[   " - " Start an ANSI escape sequence " )

( .. [4] These are updated each time the image is loaded. )

( .. [5] This parses for a vocabulary name, which should end in a single )
(     apostrophe. The apostrophe will be cut, and the a suffix of )
(     *.rx* added. The system will attempt to load the file from the )
(     *library* subdirectory in the current working directory. )

&help is boot
save bye

